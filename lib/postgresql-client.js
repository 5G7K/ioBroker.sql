// Generated by CoffeeScript 2.3.2
(function() {
    let pg = require('pg');
    let Url = require('url');
    let querystring = require('querystring');

    let SQLClient         = require('sql-client/lib/sql-client').SQLClient;
    let SQLClientPool     = require('sql-client/lib/sql-client-pool').SQLClientPool;
    let ConnectionFactory = require('sql-client/lib/connection-factory').ConnectionFactory;

    try {
        if ((pg != null ? pg['native'] : void 0) != null) {
            pg = pg['native'];
        }
    } catch(err) {

    }

    // PostgreSQLConnectionFactory does not use any of node-pg's built-in pooling.
    let PostgreSQLConnectionFactory = class PostgreSQLConnectionFactory extends ConnectionFactory {
        constructor() {
            super();
            this.open_connection = this.open_connection.bind(this);
            this.pre_process_sql = this.pre_process_sql.bind(this);
        }

        open_connection(connect_string, callback) {
            let connection = new pg.Client(connect_string);
            return connection.connect((err) => {
                return callback(err, connection);
            });
        }

        pre_process_sql(sql, bindvars, callback) {
            let index;
            if ((sql != null) && (bindvars != null)) {
                index = 1;
                sql = sql.replace(/\?/g, (function() {
                    return '$' + index++;
                }));
            }
            return callback(null, sql, bindvars);
        }
    };

    let PostgreSQLClient = class PostgreSQLClient extends SQLClient {
        constructor(...options) {
            super(...options, new PostgreSQLConnectionFactory());
        }

    };

    let PostgreSQLClientPool = class PostgreSQLClientPool extends SQLClientPool {
        constructor(...options) {
            super(...options, new PostgreSQLConnectionFactory());
        }

    };

    exports.PostgreSQLConnectionFactory = PostgreSQLConnectionFactory;
    exports.PostgreSQLClient = PostgreSQLClient;
    exports.PostgreSQLClientPool = PostgreSQLClientPool;

    let PostgreSQLConnectionFactory2 = (function() {
        // PostgreSQLConnectionFactory2 DOES usenode-pg's built-in pooling.
        class PostgreSQLConnectionFactory2 extends PostgreSQLConnectionFactory {
            constructor() {
                super();
                this._parse_connect_string = this._parse_connect_string.bind(this);
                this.open_connection = this.open_connection.bind(this);
                this.close_connection = this.close_connection.bind(this);
                this.pg_pools_by_connect_string = {};
                this._connect_string_regexp = /^([^:]+):\/\/([^:]+):([^@]+)@([^:\/]+)(:([0-9]+))?(.*)$/;
            }

            _parse_connect_string(connect_string) {
                let config;
                let matches;
                let name;
                let parsed_path;
                let path;
                let qs;
                let value;

                if (typeof connect_string === 'string' && this._connect_string_regexp.test(connect_string)) {
                    matches = connect_string.match(this._connect_string_regexp);
                    config = {};
                    config.database = matches[1];
                    config.user = matches[2];
                    config.password = matches[3];
                    config.host = matches[4];
                    if (matches[6] != null) {
                        config.port = parseInt(matches[6]);
                    }
                    path = matches[7];
                    parsed_path = Url.parse(path);
                    config.database = parsed_path.pathname.substring(1);
                    if (parsed_path.query != null) {
                        qs = querystring.parse(parsed_path.query);
                        for (name in qs) {
                            value = qs[name];
                            if (value === 'true') {
                                value = true;
                            } else if (value === 'false') {
                                value = false;
                            } else if (`${value}` === `${parseInt(value)}`) {
                                value = parseInt(value);
                            }
                            config[name] = value;
                        }
                    }
                    return config;
                } else {
                    return connect_string;
                }
            }

            open_connection(connect_string, callback) {
                let key;
                let pg_pool;

                key = connect_string;
                if (typeof key !== 'string') {
                    key = JSON.stringify(key);
                }
                pg_pool = this.pg_pools_by_connect_string[key];
                if (pg_pool == null) {
                    pg_pool = new pg.Pool(this._parse_connect_string(connect_string));
                    this.pg_pools_by_connect_string[key] = pg_pool;
                }
                return pg_pool.connect((err, client, done_fn) => {
                    let connection;
                    connection = client;
                    if (connection != null) {
                        connection._sqlclient_done = done_fn;
                        connection._pg_pool_key = key;
                    }
                    return callback(err, connection);
                });
            }

            close_connection(connection, callback) {
                if ((connection != null ? connection._sqlclient_done : void 0) != null) {
                    connection._sqlclient_done();
                    return typeof callback === "function" ? callback(null) : void 0;
                } else {
                    return super.close_connection(connection, callback);
                }
            }

        }

        return PostgreSQLConnectionFactory2;

    }).call(this);

    let PostgreSQLClient2 = class PostgreSQLClient2 extends SQLClient {
        constructor(...options) {
            super(...options, new PostgreSQLConnectionFactory2());
        }

    };

    let PostgreSQLClientPool2 = class PostgreSQLClientPool2 extends SQLClientPool {
        constructor(...options) {
            super(...options, new PostgreSQLConnectionFactory2());
            this.destroy = this.destroy.bind(this);
            this.close = this.close.bind(this);
        }

        destroy(client, callback) {
            if (client != null) {
                return client.disconnect(callback);
            } else {
                return typeof callback === "function" ? callback() : void 0;
            }
        }

        close(callback) {
            return super.close((...args) => {
                let key;
                let pg_pool;
                let pools_to_close;
                let ref;
                let ref1;
                pools_to_close = (ref = this.factory) != null ? ref.pg_pools_by_connect_string : void 0;
                ref1 = pools_to_close != null ? pools_to_close : {};
                for (key in ref1) {
                    pg_pool = ref1[key];
                    if (!((pg_pool == null) || (pg_pool.ending || pg_pool.ended))) {
                        pg_pool.end();
                    }
                }
                return typeof callback === "function" ? callback(...args) : void 0;
            });
        }
    };

    exports.PostgreSQLConnectionFactory2 = PostgreSQLConnectionFactory2;
    exports.PostgreSQLClient2 = PostgreSQLClient2;
    exports.PostgreSQLClientPool2 = PostgreSQLClientPool2;
}).call(this);
